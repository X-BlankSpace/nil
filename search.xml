<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[tyvj 1011 传纸条]]></title>
      <url>http://x-blankspace.github.io/2016/10/21/tyvj-1011-%E4%BC%A0%E7%BA%B8%E6%9D%A1/</url>
      <content type="text"><![CDATA[从左上角的(1,1)点走到右下角的(m,n)点(只能往右或下走)，再从(m,n)点走到(1,1)(只能往左或上走)点，除了起点和终点外，两条路径上的点不能重复。起点和终点的权值均为0，求两条路径权值之和的最大值。可以看成两个人同时从(1,1)出发，走到(m,n)点，用双线程DP。由于从(1,1)到(m,n)的曼哈顿距离一定，为m+n，所以可以通过走的步数来递推。设g[][]为每个点的权值,dp[i][j][k]表示第一个人走到第i行，第二个人走到第j行，两个人均走了k步所能得到的最大权值，其中i&lt;=j，当且仅当两人均走到(m,n)即i==m&amp;&amp;k==m+n-2时i==j。列数可由当前行数和所走步数推算出。易知上一位置只能在当前位置的左或者上边，所以共有2*2种可能，如下12dp[i][j][k]=max(dp[i][j][k-1],dp[i-1][j][k-1],dp[i-1][j-1][k-1],dp[i][j-1][k-1])+g[i][k-i+2]+g[j][k-j+2];其中j&gt;i||j==i&amp;&amp;i==m&amp;&amp;k==m+n-2 不合法的路径不计算，默认值为0，对结果无影响。12345678910111213141516171819#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;#define max(a,b) ((a)&gt;(b)?(a):(b))int n,m,g[50+5][50+5],dp[50+5][50+5][98+5];int main()&#123; scanf("%d%d",&amp;m,&amp;n); for(int i=1;i&lt;=m;i++) for(int j=1;j&lt;=n;j++) scanf("%d",&amp;g[i][j]); for(int k=1;k&lt;=m+n-2;k++) for(int i=1;i&lt;=m&amp;&amp;i-1&lt;=k;i++) for(int j=(i==m&amp;&amp;k==m+n-2)?i:i+1;j&lt;=m&amp;&amp;j-1&lt;=k;j++)&#123; dp[i][j][k]=max(max(dp[i][j][k-1],dp[i-1][j][k-1]),max(dp[i-1][j-1][k-1],dp[i][j-1][k-1])); dp[i][j][k]+=g[i][k-i+2]+g[j][k-j+2]; &#125; printf("%d\n",dp[m][m][m+n-2]); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://x-blankspace.github.io/2016/10/17/hello-world/</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[tyvj 1008 传球游戏]]></title>
      <url>http://x-blankspace.github.io/2016/10/08/tyvj-1008-%E4%BC%A0%E7%90%83%E6%B8%B8%E6%88%8F/</url>
      <content type="text"><![CDATA[游戏规则：n个同学站成一个圆圈，其中的一个同学手里拿着一个球，每个同学可以把球传给自己左右的两个同学中的一个(左右任意)。 问题：有多少种不同的传球方法可以使得从1号同学手里开始传的球，传了m次以后，又回到1号手里。 两种传球的方法被视作不同的方法，当且仅当这两种方法中，接到球的同学按接球顺序组成的序列是不同的。比如有3个同学1号、2号、3号，并假设小蛮为1号，球传了3次回到小蛮手里的方式有1-&gt;2-&gt;3-&gt;1和1-&gt;3-&gt;2-&gt;1，共2种。 球从同学i传到j可以分解为i-&gt;…-&gt;j.pre–&gt;j或i-&gt;…-&gt;j.next-&gt;j两种，用dt[i][j][k]表示i传到j，传了k次的方法总数，则12dt[i][j][k]=dt[i][j.pre][k-1]+dt[i][j.next][k-1]其中dt[i][i][0]=1; 显然dt[i][j][k]=dt[j][i][k],所以在求解的时候只要求矩阵对角线的一侧即可。 但是这样要用三维数组，如果把最后一维去掉，算的时候受顺序制约，所以不行。 重新定义，题目要求的是从1出发回到1的方法数，可以把起点固定为1，定义dt[j][k]为从1到j，传了k次的方法数。则12dt[j][k]=dt[j.pre][k-1]+dt[j.next][k-1]其中dt[1][0]=1; 定义一1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int dt[30][30][31];int main()&#123; int m,n; scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;30;i++) dt[i][i][0]=1; for(int k=1;k&lt;=m;k++) &#123; for(int i=0;i&lt;n;i++) for(int j=i;j&lt;n;j++)&#123; int pre=j==0?n-1:j-1,next=j==n-1?0:j+1; dt[i][j][k]=dt[i][pre][k-1]+dt[i][next][k-1]; &#125; for(int i=0;i&lt;n;i++) for(int j=i-1;j&gt;=0;j--) dt[i][j][k]=dt[j][i][k]; &#125; printf("%d\n",dt[0][0][m]); return 0;&#125; 定义二1234567891011121314151617&#125;#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int dt[30][31];int main()&#123; int m,n; scanf("%d%d",&amp;n,&amp;m); dt[0][0]=1; for(int k=1;k&lt;=m;k++) for(int j=0;j&lt;n;j++)&#123; int pre=j==0?n-1:j-1,next=j==n-1?0:j+1; dt[j][k]=dt[pre][k-1]+dt[next][k-1]; &#125; printf("%d\n",dt[0][m]); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LA3942 Remember the word]]></title>
      <url>http://x-blankspace.github.io/2015/12/05/LA3942-Remember-the-word/</url>
      <content type="text"><![CDATA[给出一个由S个不同单词组成的字典和一个长字符串Str。把这个字符串分解成若干个单词的连接（单词可以重复使用），有多少种方法？比如，有4个单词a,b,cd,ab，则abcd有两种分解方法：a+b+cd和ab+cd。 输入包含多组数据，每组数据第一行为待分解的字符串，其长度L不超过300 000。第二行为单词个数S，$1\leq S\leq4000$。 以下S行每行为一个单词，由不超过100个小写字母组成。对每组数据输出方案数模20 071 027。 递推：令d(i)表示字符串Str[i…(L-1)]的分解方案数，d(i)=sum{d(i+len(x) | 单词x是Str[i…(L-1)]的前缀}，若Str[i…(L-1)]在字典中，则d(i)应加1。用Trie来保存字符串集合，单词的长度最大为100，求解d(i)时最多只需要判断100次。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int maxnode=4000*100+10,maxsize=26;int ch[maxnode][maxsize],val[maxnode],sz;int idx(char c) &#123; return c-'a'; &#125; void insert(char *s)&#123; int u=0,n=strlen(s); for(int i=0;i&lt;n;i++)&#123; int c=idx(s[i]); if(!ch[u][c])&#123; memset(ch[sz],0,sizeof(ch[sz])); val[sz]=0; ch[u][c]=sz++; &#125; u=ch[u][c]; &#125; val[u]=1; &#125;int d[300000+10],kase;char words[4000+10][100+5],str[300000+10];int main()&#123; int n; while(~scanf("%s",str))&#123; memset(val,0,sizeof(val)),memset(d,0,sizeof(d)); scanf("%d",&amp;n); sz=1;memset(ch[0],0,sizeof(ch[0])); for(int i=0;i&lt;n;i++) &#123; scanf("%s",words[i]);insert(words[i]); &#125; int len=strlen(str); d[len-1]=ch[0][str[len-1]-'a']?1:0; for(int i=len-2;i&gt;=0;i--)&#123; int u=0,j=i; while(j&lt;=len-1&amp;&amp;ch[u][str[j]-'a'])&#123; if(val[ch[u][str[j]-'a']]) d[i]+=d[j+1],d[i]%=20071027; u=ch[u][str[j]-'a']; j++; &#125; if(j==len&amp;&amp;val[u]) d[i]++; &#125; printf("Case %d: %d\n",++kase,d[0]%20071027); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[判断一个数能否被一些特殊自然数整除的方法及其证明]]></title>
      <url>http://x-blankspace.github.io/2015/11/23/%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E8%83%BD%E5%90%A6%E8%A2%AB%E4%B8%80%E4%BA%9B%E7%89%B9%E6%AE%8A%E8%87%AA%E7%84%B6%E6%95%B0%E6%95%B4%E9%99%A4%E7%9A%84%E6%96%B9%E6%B3%95%E5%8F%8A%E5%85%B6%E8%AF%81%E6%98%8E/</url>
      <content type="text"><![CDATA[判断一个数能否被一些特殊自然数如7，11，13，19，23，29，59，79，89等整除的方法及其证明。 判断一个数能否被11整除的方法若一个数的奇数位数字之和与偶数位数字之和之差为11的倍数，则该数能被11整除。易知任意一个长度为$n$的正整数可表示为$A_nA_{n-1}A_{n-2}…A_2A_1$，其中$A_n$到$A_1$分别代表其最高位到最低位的数字。约定：若其中一个数字$A_i$的下标$i$为奇数，则称$A_i$为该数的奇数位，同理，若$i$为偶数，则称$A_i$为该数的偶数位。 证明如下：任意一个非负整数$x$可表示为$a×100+b×10+c$，其中a,b,c为非负整数，且$0\leq a,b\leq9$，故$x\%11=(a×100+b×10+c)\%11$， 又$100\%11=1$，$10\%11=-1$，所以$(a×100+b×10+c)\%11=(a-b+c)\%11=[a+(c-b)]\%11……*$，其中c、b分别为x的奇数位、偶数位， 继续将a按上述方式展开，直到$0\leq a\leq9$，若*式值为0，即$x$的奇数位数字之和与偶数位数字之和之差为11的倍数，则$x\%11=0$，即$x$能被11整除。 证毕 判断一个数能否被13整除的方法删去该数的末位，再加上末位数的4倍，重复上述操作，直到得到一个两位数，若这个两位数能被13整除，则该数能被13整除。证明如下:易知任意一个长度为$n$的正整数可表示为$A_nA_{n-1}A_{n-2}…A_2A_1$且$A_nA_{n-1}A_{n-2}……A_2A_1=A_nA_{n-1}A_{n-2}……A_2×10+A_1$ 若$(A_nA_{n-1}A_{n-2}……A_2+4×A_1)\%13=0$则$A_nA_{n-1}A_{n-2}……A_2+4×A_1=13k……*$，$k$为整数。 由*式乘以10得$10×A_nA_{n-1}A_{n-2}……A_2+40×A_1=130k$故$10×A_nA_{n-1}A_{n-2}……A_2+A_1=130k-39×A_1$ 显然$(130k-39×A_1)\%13=0$故$(10×A_nA_{n-1}A_{n-2}……A_2+A_1)\%13=0$，即$A_nA_{n-1}A_{n-2}……A_2A_1\%13=0$。 对于其他特殊的整数，证明方法类似。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[USACO 1.1.4 Mother's Milk]]></title>
      <url>http://x-blankspace.github.io/2015/11/16/USACO-1-1-4-Mother-s-Milk/</url>
      <content type="text"><![CDATA[农民约翰有三个容量分别是 A,B,C 升的桶,A,B,C 分别是三个从 1 到 20 的整数,最初,A 和 B 桶都是空的,而 C 桶是装满牛奶的.有时,约翰把牛奶从一个桶倒到另一个桶中,直到被灌桶装满或原桶空了.当然每一次灌注都是完全的.由于节约,牛奶不会有丢失.写一个程序去帮助约翰找出当 A 桶是空的时候,C 桶中牛奶所剩量的所有可能性. BFS广搜，状态数一定不超过21×21×21 code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int a,b,c,vl[21],vis[21][21][21],q[9621+100]; void bfs()&#123; int front=0,rear=1; vis[0][0][c]=1,vl[c]=1,q[0]=c; while(front&lt;rear)&#123; int ta=q[front]/441,tb=(q[front]-ta*441)/21,tc=q[front]%21; if(ta&gt;0) &#123; if(tb&lt;b)&#123; if(b-tb&gt;ta&amp;&amp;!vis[0][tb+ta][tc]) tb+=ta,ta=0,vis[ta][tb][tc]=1,q[rear++]=ta*441+tb*21+tc,vl[tc]=1; else if(b-tb&lt;=ta&amp;&amp;!vis[ta-(b-tb)][b][tc]) ta-=(b-tb),tb=b,vis[ta][tb][tc]=1,q[rear++]=ta*441+tb*21+tc; if(ta==0) vl[tc]=1; &#125; ta=q[front]/441,tb=(q[front]-ta*441)/21,tc=q[front]%21; //重新初始化 if(tc&lt;c)&#123; if(c-tc&gt;ta&amp;&amp;!vis[0][tb][tc+ta]) tc+=ta,ta=0,vis[ta][tb][tc]=1,q[rear++]=ta*441+tb*21+tc,vl[tc]=1; else if(c-tc&lt;=ta&amp;&amp;!vis[ta-(c-tc)][tb][c]) ta-=(c-tc),tc=c,vis[ta][tb][tc]=1,q[rear++]=ta*441+tb*21+tc; if(ta==0) vl[tc]=1; &#125; &#125; ta=q[front]/441,tb=(q[front]-ta*441)/21,tc=q[front]%21; if(tb&gt;0) &#123; if(ta&lt;a)&#123; if(a-ta&gt;tb&amp;&amp;!vis[ta+tb][0][tc]) ta+=tb,tb=0,vis[ta][tb][tc]=1,q[rear++]=ta*441+tb*21+tc; else if(a-ta&lt;=tb&amp;&amp;!vis[a][tb-(a-ta)][tc]) tb-=(a-ta),ta=a,vis[ta][tb][tc]=1,q[rear++]=ta*441+tb*21+tc; if(ta==0) vl[tc]=1; &#125; ta=q[front]/441,tb=(q[front]-ta*441)/21,tc=q[front]%21; if(tc&lt;c)&#123; if(c-tc&gt;tb&amp;&amp;!vis[ta][0][tc+tb]) tc+=tb,tb=0,vis[ta][tb][tc]=1,q[rear++]=ta*441+tb*21+tc; else if(c-tc&lt;=tb&amp;&amp;!vis[ta][tb-(c-tc)][c]) tb-=(c-tc),tc=c,vis[ta][tb][tc]=1,q[rear++]=ta*441+tb*21+tc; if(ta==0) vl[tc]=1; //虽然ta的值没有变化，但是可能一开始ta==0，之后tb,tc变化又产生了新的解 &#125; &#125; ta=q[front]/441,tb=(q[front]-ta*441)/21,tc=q[front]%21; if(tc&gt;0) &#123; if(ta&lt;a)&#123; if(a-ta&gt;tc&amp;&amp;!vis[ta+tc][tb][0]) ta+=tc,tc=0,vis[ta][tb][tc]=1,q[rear++]=ta*441+tb*21+tc; else if(a-ta&lt;=tc&amp;&amp;!vis[a][tb][tc-(a-ta)]) tc-=(a-ta),ta=a,vis[ta][tb][tc]=1,q[rear++]=ta*441+tb*21+tc; if(ta==0) vl[tc]=1; &#125; ta=q[front]/441,tb=(q[front]-ta*441)/21,tc=q[front]%21; if(tb&lt;b)&#123; if(b-tb&gt;tc&amp;&amp;!vis[ta][tb+tc][0]) tb+=tc,tc=0,vis[ta][tb][tc]=1,q[rear++]=ta*441+tb*21+tc; else if(b-tb&lt;=tc&amp;&amp;!vis[ta][b][tc-(b-tb)]) tc-=(b-tb),tb=b,vis[ta][tb][tc]=1,q[rear++]=ta*441+tb*21+tc; if(ta==0) vl[tc]=1; &#125; &#125; front++; &#125;&#125;int main()&#123; memset(vl,0,sizeof(vl)),memset(vis,0,sizeof(vis)); freopen("milk3.in","r",stdin); freopen("milk3.out","w",stdout); scanf("%d%d%d",&amp;a,&amp;b,&amp;c); bfs(); int flag=0; for(int i=0;i&lt;=c;i++) &#123; if(vl[i])&#123; if(!flag)&#123; flag=1;printf("%d",i); &#125; else printf(" %d",i); &#125; &#125; puts(""); return 0;&#125;]]></content>
    </entry>

    
  
  
</search>
